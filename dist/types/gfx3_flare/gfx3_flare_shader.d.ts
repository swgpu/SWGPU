export declare const SHADER_VERTEX_ATTR_COUNT = 4;
export declare const PIPELINE_DESC: any;
export declare const VERTEX_SHADER = "\nstruct VertexOutput {\n  @builtin(position) Position: vec4<f32>,\n  @location(0) FragUV: vec2<f32>\n};\n\n@group(0) @binding(0) var<uniform> RESOLUTION: vec2<f32>;\n@group(1) @binding(1) var<uniform> TRANSLATION: vec2<f32>;\n@group(1) @binding(2) var<uniform> SCALE: vec2<f32>;\n@group(1) @binding(3) var<uniform> ANGLE: f32;\n@group(1) @binding(4) var<uniform> SIZE: vec2<f32>;\n@group(1) @binding(5) var<uniform> OFFSET: vec2<f32>;\n\n@vertex\nfn main(\n  @location(0) Pos: vec2<f32>,\n  @location(1) TexUV: vec2<f32>\n) -> VertexOutput {\n  var c = cos(ANGLE);\n  var s = sin(ANGLE);\n  var transformedPos = Pos * SIZE + OFFSET;\n  transformedPos = transformedPos * SCALE;\n  transformedPos = vec2(c * (transformedPos.x) + s * (transformedPos.y), c * (transformedPos.y) - s * (transformedPos.x));\n\n  var screenPos = transformedPos + TRANSLATION;\n  var normScreenPos = screenPos / RESOLUTION;\n  var clipPos = normScreenPos * 2.0 - 1.0;\n  clipPos.y = clipPos.y * -1;\n\n  var output: VertexOutput;\n  output.Position = vec4<f32>(clipPos, 0, 1);\n  output.FragUV = TexUV;\n  return output;\n}";
export declare const FRAGMENT_SHADER = "\nstruct FragOutput {\n  @location(0) Base: vec4f,\n  @location(1) Normal: vec4f,\n  @location(2) Id: vec4f\n}\n\n@group(1) @binding(0) var<uniform> ID: vec4<f32>;\n@group(1) @binding(6) var<uniform> COLOR: vec4<f32>;\n@group(2) @binding(0) var TEXTURE: texture_2d<f32>;\n@group(2) @binding(1) var SAMPLER: sampler;\n\n@fragment\nfn main(\n  @builtin(position) Position: vec4<f32>,\n  @location(0) FragUV: vec2<f32>\n) -> FragOutput {\n  var output: FragOutput;\n  output.Base = textureSample(TEXTURE, SAMPLER, FragUV) * COLOR;\n  output.Normal = vec4(0.0, 0.0, 0.0, 0.0);\n  output.Id = ID;\n  return output;\n}";
